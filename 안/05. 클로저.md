## closure

클로저는 유효범위를 말한다. 어디서 실행되었느냐가 아니라 어디서 정의되었느냐 따라서 달라진다.

- 외부함수 스코프에서 내부함수 스코프로 접근 불가능하다.
- 내부함수에서는 외부함수 스코프에서 선언된 변수에 접근 기능하다.

```js
const l0 = "l0";

function fn2() {
  const l2 = "l2";
  console.log(l0, l1, l2); // 에러 -> l1 은 접근 불가!!
}

function fn1() {
  const l1 = "l1";
  fn2();
}
fn1();

// 함수안에서 정의

const l0 = "l0";

function fn1() {
  function fn2() {
    const l2 = "l2";
    console.log(l0, l1, l2); // 정상 출력됨
  }
  const l1 = "l1";
  fn2();
}
fn1();
```

<br>

```js
const outer = function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  return inner;
};

const outer2 = outer();
console.log(outer2()); // 2
console.log(outer2()); // 3
```

inner 함수의 실행 시점에는 outer 함수는 이미 실행이 종료된 상태인데 outer 함수의 lexicalEnvironment에 접근할 수 있는 이유

> outer 함수는 실행 종료 시점에 inner 함수를 반환한다. 외부함수인 outer의 실행이 종료되더라도 내부 함수인 inner 함수는 언젠가
> outer2를 실행함으로써 호출될 가능성이 열린 것!! 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않는다.

<br>

정리 : **클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상**

## 클로저와 메모리 관리

클로저는 그 본질이(참조하는 값이 있기 때문에) 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리 관리를 해줄 필요가 있다.
<br>
필요성이 사라진 시점에는 더는 메모리를 소모하지 않게 해주면 된다. 방법은 간단하다

```js
const outer = (function () {
  let a = 1;
  const inner = function () {
    return ++a;
  };
  return inner;
})();

console.log(outer());
console.log(outer());
outer = null; // outer 식별자의 inner 함수 참조를 끊음
```
