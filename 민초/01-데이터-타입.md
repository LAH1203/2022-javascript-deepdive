# 01. 데이터 타입

## 1-1. 데이터 타입의 종류

- 기본형 : Number, String, Boolean, null, undefined, Symbol
- 참조형 : Object(Array, Date, RegExp, Map, WeakMap, Set, WeakSet, ...)
- 기본형 vs 참조형?
  - 기본형은 불변성을 띈다.
  - 기본형은 값이 담긴 주솟값을 바로 복제.
  - 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제.
- 데이터 타입이 왜 필요할까?
  - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
  - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
  - 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해


<br>

## 1-2. 데이터 타입에 관한 배경지식

- 모든 데이터는 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.

- 변수 vs 식별자?
  - 변수는 `변할 수 있는 무언가(데이터)` 즉, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체.
  - 식별자는 `어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명`
  - 모든 식별자는 실행 컨텍스트에 키/값 형식인 객체로 등록되어 관리된다.

- 정적 타입 vs 동적 타입?

  - 정적 타입 언어 : 컴파일 시점에 타입을 확인.
  - **동적 타입 언어 : 런타임 시점에 타입을 확인.**

- 자바스크립트에서는 타입이 맞지 않으면 묵시적 타입 변환을 함.

  ```js
  console.log('3' * '4') // 12
  ```

<br>

## 1-3. 변수 선언과 데이터 할당

```js
var a;
a = 'abc';

var a = 'abc';
```

### 할당 과정 살펴보기!

- 변수 영역에서 빈 공간(@1003)을 확보
- 확보한 공간의 식별자를 a로 지정
- 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장
- 변수 영역에서 a라는 식별자를 검색(@1003)
- 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

### 왜 이렇게 저장하나요?

- 미리 확보한 공간 내에서 데이터를 추가로 저장하려면 매번 메모리를 늘리는 작업이 필요.
- 맨 끝에 있는 데이터라면 문제 없을 수 있지만, 메모리 영역 중간에 있는 데이터라면?
- 해당 공간보다 뒤에 저장한 데이터를 전부 뒤로 옮기고, 이동한 주소에 대해 식별자를 다시 연결하는 작업을 해야한다. (컴퓨터가 힘들어요 ㅠㅠ)

### JS 엔진의 변수 선언 단계

- 선언 단계 : 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다. (엄밀히 말하면 접근할 때 undefined를 반환. - 코어 자바스크립트)

### 호이스팅

```js
console.log(score); // undefined

var score;
```

- console.log에서 참조 에러가 발생할 것 같은데 왜 undefined가 나오지?
- **변수 선언은 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문!**
- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 함.

<br>

## 1-4. 기본형 데이터와 참조형 데이터

### 불변값

- 변수 vs 상수?
  - 바꿀 수 있으면 변수, 바꿀 수 없으면 상수
  - 변수와 상수를 구분 짓는 변경 가능성의 대상 : **변수 영역** 메모리
  - 재할당이 가능한지 불가능한지 여부가 관건!
- 불변성 여부를 구분할 때의 변경 가능성의 대상 : **데이터 영역** 메모리
- 기본형 데이터는 모두 불변값.

```js
var = 'abc';
a = a + 'def';
```

- 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라, 완전히 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장.
- 즉, 'abc'와 'abcdef'는 완전히 별개의 데이터임.
- 문자열과 같은 불변값들은 한 번 만든 값을 바꿀 수 없고, 변경은 새로 만드는 동작을 통해서만 이루어진다. 내가 누구? **불변값**

### 가변값

#### 참조형 데이터의 기본 할당 방식

```js
var obj1 = {
  a: 1,
  b: 'bbb',
}
```

- 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정.
- 임의의 데이터 공간(@5001)에 데이터를 저장하려고 했는데~ 여러 개의 프로퍼티로 이루어졌네? 아 한 번에 못넣겠네;;
- 프로퍼티를 저장하기 위한 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ ?)를 @5001에 저장.
- @7103, @7104에 각각 a와 b라는 프로퍼티 이름을 지정.
- 데이터 영역에서 숫자 1 검색, 없네? 임의로 @5003에 저장. 그리고 이 주소를 @7103에 저장.
- 데이터 영역에서 문자열 'bbb' 검색, 없네? 임의로 @5004에 저장. 그리고 이 주소를 @7104에 저장.

#### 기억할 점

- `obj1.a = 2;`와 같이 내부 프로퍼티 값을 변경하는 경우 obj1이 바라보는 주소는 변하지 않는다. 기존 객체 내부의 값만 변경한다.
- 객체의 프로퍼티로 배열(객체)가 있는 경우? 이 배열(객체)은 참조형 데이터의 기본 할당 방식과 마찬가지로, 프로퍼티를 저장하기 위한 주솟값들로 이루어진 묶음을 값에 저장 -> 이후 과정도 동일하다.
- 참조 카운트가 0인 메모리 주소는 GC의 수거 대상이된다.

#### 변수 복사 비교

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

- 기본형 데이터 (`a, b`)
  - a와 b의 값은 달라짐.
  - a와 b는 서로 다른 주소를 바라보게 됨.
- 참조형 데이터 (`obj1, obj2`)
  - obj1과 obj2의 값은 달라지지 않음.
  - obj1과 obj2는 같은 객체를 바라보고 있음.
- 만약 `obj2 = { c: 20, d: 'ddd' };`와 같이 새로운 객체를 할당하면?
  - obj1과 obj2는 각각 다른 객체를 바라보게 됨.

- **가변값?** 
  - 참조형 데이터 내부의 프로퍼티를 변경할 수 있다는 의미.
  - 프로퍼티를 자유롭게 추가, 변경, 제거할 수 있음.

- 데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.

<br>

## 1-5. 불변 객체

### 불변 객체 만들기

- 객체의 가변성으로 인한 문제점

  ```js
  var user = {
    name: 'hope',
    gender: 'female',
  }
  
  var changeName = function (user, newName) {
    var newUser = user;
    newUser.name = newName;
    return newUser;
  }
  
  var user2 = changeName(user, 'beer');
  
  console.log(user.name, user2.name); // beer beer
  console.log(user === user2); // true
  ```

  - 원본 객체도 같이 바뀌어 버리는 문제!

- 해결 방법

  - changeName 내부에서 새로운 객체를 리턴. but 변경할 필요가 없는 기존 객체의 프로퍼티를 하나하나 하드코딩 해야함. 비효율적이다.
  - 얕은 복사와 깊은 복사!

### 얕은 복사 vs 깊은 복사

- 얕은 복사 : 바로 아래 단계의 값만 복사.

  ```js
  var copyObject = function (target) {
    var result = {};
    for (var prop in target) {
      result[prop] = target[prop];
    }
    return result;
  }
  ```

- 깊은 복사 : 내부의 모든 값들을 하나하나 찾아서 전부 복사.

  ```js
  var copyObjectDeep = function(target) {
    var result = {};
    if (typeof target === 'object' && target !== null) {
      for (var prop in target) {
        result[prop] = copyObjectDeep(target[prop]);
      }
    } else {
      result = target;
    }
    return result;
  }
  ```

- JSON을 활용한 깊은 복사

  ```js
  var copyObjectViaJSON = function (target) {
    return JSON.parse(JSON.stringify(target));
  };
  var obj = {
    a: 1,
    b: {
      c: null,
      d: [1, 2],
      func1: function () { console.log(3); }
    },
      func2: function () { console.log(4); }
  }
  
  var obj2 = copyObjectViaJSON(obj);
  obj2.a = 3;
  obj2.b.c = 4;
  obj.b.d[1] = 3;
  
  console.log(obj); // { a: 1, b: { c: null, d: [1, 3], func1: f() }, func2: f() }
  console.log(obj2); // { a: 3, b: { c: 4, d: [1, 2] } }
  ```

  - 주의 : `__proto__`, `getter/setter`와 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시.

<br>

## 1-6. undefined와 null

### undefined

- JS 엔진이 undefined를 반환하는 경우?
  - 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때 (초기화되지 않은 변수)
  - 제공하지 않은 매개변수
  - 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
  - return문이 없거나 호출되지 않는 함수의 실행 결과

### null

- JS 엔진이 null를 반환하는 경우?
  - 프로토타입 체인의 마지막 요소
  - 정규 표현식에 맞는 부분이 없을 때  `예 : /x/.exec('aaa') -> null`
  - document.querySelector에서 조건에 부합하는 HTML 요소를 검색할 수 없는 경우
- 명시적으로 비어있음을 나타내고 싶을 때 사용하자.
- typeof null은 object임에 주의! (x === null과 같이 일치연산자로 체크하자)

<br>

## 1-7 표현식과 문

### 표현식

```js
10
'Hello'

person.name

10 + 20
sum = 10

square()
```

- 값으로 평가될 수 있는 것은 모두 표현식.

### 문

- 프로그램을 구성하는 기본 단위이자 최소 실행 단위.
- 변수 선언문, 할당문, 함수 선언문, 조건문, 반복문 등.

### 표현식인 문 vs 표현식이 아닌 문

```js
var x; // 표현식이 아닌 문
var foo = var x; // Error!

x = 1 + 2; // 표현식인 문
var foo = x = 100; // 할당 가능!
```

- 표현식이 아닌 문은 값처럼 사용 불가. (변수에 할당 X)
- 표현식인 문은 값처럼 사용 가능. (변수에 할당 O)

<br>

# 참고

- 코어 자바스크립트 
  - `1. 데이터 타입`
- 모던 자바스크립트 Deep Dive
  - `4. 변수`
  - `5. 표현식과 문`
  - `6. 데이터 타입`
  - `11. 원시 값과 객체의 비교`
- 자바스크립트를 말하다
  - `8. 값`