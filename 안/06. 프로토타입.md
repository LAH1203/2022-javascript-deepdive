## 프로토타입

```js
const Person = function (name) {
  this._name = name;
};

Person.prototpye.getName = function () {
  return this._name;
};

const ahn = new Person("Ahn");
ahn.__proto__.getName(); // undefinded
```

`ahn.__proto__.getName();` undefinded 가 출력되는걸 보아 this 바인딩된 대상이 잘못 지정됐다는걸 알 수 있다.
<br>
`ahn.__proto__.getName()` 에서 getName 함수 내부에서의 this는 ahn이 아니라 `ahn.__proto__`라는 객체가 된다.
이 객체 내부에는 name 프로퍼티가 없으므로 찾고자 하는 식별자가 정의돼 있지 않을 때는 error 대신 undefined를 반환한다.

## 예시

<img width="800" alt="스크린샷 2022-04-16 오후 1 13 53" src="https://user-images.githubusercontent.com/82227098/163660989-94dc5908-0648-437d-bc3e-74faf7291de5.png">

함수라는 객체를 생성했을 때 그 객체에는 prototype이라는 object가 자동으로 생성된다. 그 프로토타입에는 역시 constructor라는 객체가 자동으로 생성되어 서로를 참조할 수 있게 된다.

> Person.prototype.sum = function(){}

위의 코드를 통해서 prototype에 `sum`함수를 추가함으로써 여러 객체를 생성하였을 때 해당함수를 사용할 수 있게 한다.

### 사용할 수 있는 이유

Person의 인스턴스를 새로 생성했을 때 해당 인스턴스의 Person의 prototype 링크인 `__proto__` object를 새로 부여받기 때문이다.

### 만약 sum()함수를 둘 다 가지고 있으면?

자바스크립트 엔진이 가장 가까운 대상인 자신의 프로퍼티를 검색하고, 없으면 그다음으로 가까운 대상인 `__proto__`를 검색하는 순서로 진행된다. `__proto__`에 있는 메서드는 자신에게 있는 메서드보다 검색 순서에서 밀려 호출되지 않는다.

이렇게 프로토타입이 `__proto__`링크로 연결되어 있는 형태를 프로토타입 체인 형태 라고 한다.

## 프로토타입 장점

```js
// this 사용

function Toy(name) {
  this.name = name;
  this.battery = 100;
  this.charge = function () {
    battery += 10;
    console.log(`charging is finished. battery is ${this.battery}`);
  };
}

const woody = new Toy("woody");
const buzz = new Toy("buzz");

// prototype 사용

function Toy(name) {
  this.name = name;
  this.battery = 100;
}

Toy.prototype.charge = function () {
  this.battery += 10;
  console.log(`charging is finished. battery is ${this.battery}`);
};

const woody = new Toy("woody");
const buzz = new Toy("buzz");
```

> prototype은 모든 객체가 공유하고 있어서 한 번만 만들어지지만, this에 넣은 것은 객체 하나를 만들 때마다 메소드도 하나씩 만들어지기 때문에 **불필요한 메모리 낭비**가 발생한다.
